\chapter{Processi e Metodi}
\label{cap:processi-metodologie}

\textit{\indent Questo capitolo fronisce in dettaglio l'ambiente di ricerca adottato, le tecnologie impiegate e degli esperimenti condotti. 
Fornisce inoltre tutte le informazioni necessarie per replicare gli esperimenti.}

\section{Ambiente}
~\\
\indent Questa sezione offre una panoramica completa dell'ambiente di lavoro e delle tecnologie impiegate nello sviluppo degli esperimenti descritti successivamente. 
Segue una descrizione degli strumenti utilizzati durante lo svolgimento del progetto (riassunte con le relative versioni nella Figura \ref{table-tecnologie}).
\\\\
Come premessa, la totalità del progetto è stata svolta su \textbf{\emph{Ubuntu}}\footnote{\url{https://ubuntu.com/}}. 
Questa scelta di sistema operativo è dovuta al vasto supporto di strumenti per l'analisi e lo sviluppo.
\\\\
Per l'analisi del traffico di rete, è stato ampiamente utilizzato \textbf{\emph{Wireshark}}\footnote{\url{https://www.wireshark.org/}}, 
uno strumento molto diffuso nel panorama del traffico di rete e che ha permesso di esaminare nel dettaglio il comportamento dei protocolli oggetti dello studio.
\\\\
La sperimentazione ha coinvolto l'uso di diversi \emph{browser web}, in particolare \textbf{\emph{Google Chrome}}\footnote{\url{https://www.google.com/intl/it_it/chrome/}} e \textbf{\emph{Firefox}}\footnote{\url{https://www.mozilla.org/it/firefox/}}. 
Questi due applicativi sono stati impiegati per testare e confrontare l'implementazione dei protocolli in diverse situazioni.
\\\\
L'ambiente di test è stato realizzato tramite \textbf{Oracle VM VirtualBox}\footnote{\url{https://www.virtualbox.org/}}, un diffuso ambiente di virtualizzazione. 
Permettendo di creare e gestire macchine virtuali specifiche per la creazione di possibili scenari.
\\\\
Per la condivisione e mantenimento del codice si è usato \textbf{GitHub}\footnote{\url{https://github.com/}} e \textbf{Git}.
In particolare si è rivelato vantaggioso in quanto ha permesso di lavorare efficientemente con \emph{fork}\footnote{\gls{fork}} di librerie pubbliche, consentendo una gestione dinamica delle modifiche e degli aggiornamenti del codice.

\subsection{Tecnologie Specifiche per QUIC}
~\\
\indent Per lo studio si è utilizzato \textbf{Quic-go}\footnote{\url{https://github.com/quic-go/quic-go}}, un'implementazione sviluppata in \emph{Go}\footnote{\gls{Go}} del protocollo \emph{QUIC}.
\emph{Quic-go} è un progetto \emph{open source} su \emph{GitHub} che aderisce rigorosamente alle specifiche del protocollo \emph{QUIC} 
definite negli \emph{RFC}\footnote{\gls{RFC}} 9000, 9001 e 9002. 
\\\\
\emph{Quic-go} non è l'unica versione disponibile del protocollo \emph{QUIC}.
Come illustrato nella Figura \ref{table-implementazioni-quic}, esistono numerose altre implementazioni, sia \emph{open source} che proprietarie, ciascuna cerca di rispettare rigorosamente le specifiche definite negli \emph{RFC}. 
\\\\
La scelta di utilizzare questa specifica implementazione di \emph{QUIC} è motivata dal suo utilizzo all'interno di \textbf{Caddy}\footnote{\url{https://caddyserver.com/}}, un \emph{web server} moderno e performante. \emph{Caddy} integra \emph{Quic-go} per offrire il supporto nativo del protocollo \emph{QUIC} e \emph{HTTP/3}.
Inoltre, si è utilizzato \textbf{xCaddy}, un \emph{tool} che consente di creare build personalizzate di \emph{Caddy}, adattandolo alle specifiche esigenze del progetto.

\begin{figure}[!h]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Nome} & \textbf{Linguaggio} & \textbf{Licenza} \\
        \hline
        Chromium & C++ & BSD License \\
        \hline
        MsQuic & C & MIT License \\
        \hline
        QUIC Library (mvfst) & C++ & MIT License \\
        \hline
        LiteSpeed QUIC Library (lsquic) & C & MIT License \\
        \hline
        ngtcp2 & C & MIT License \\
        \hline
        Quiche & Rust & BSD-2-Clause License \\
        \hline
        quicly & C & MIT License \\
        \hline
        \textbf{quic-go} & \textbf{Go} & \textbf{MIT License} \\
        \hline
        Quinn & Rust & Apache License 2.0 \\
        \hline
        Neqo & Rust & Apache License 2.0 \\
        \hline
        aioquic & Python & BSD-3-Clause License \\
        \hline
        picoquic & C & BSD-3-Clause License \\
        \hline
        pquic & C & MIT License \\
        \hline
        QUANT & C & BSD-2-Clause License \\
        \hline
        quic & Haskell & BSD-3-Clause License \\
        \hline
        netty-incubator-codec-quic & Java & Apache License 2.0 \\
        \hline
        nodejs-quic & NodeJs & MIT License \\
        \hline
        s2n-quic & Rust & Apache License 2.0 \\
        \hline
        swift-quic & Swift & Apache License 2.0 \\
        \hline
        TQUIC & Rust & Apache License 2.0 \\
        \hline
        nginx & C & BSD-2-Clause License \\
        \hline
        HAProxy & C & GNU General Public License version 2 \\
        \hline
        kwik & Java & GNU Lesser General Public License version 3 \\
        \hline
    \end{tabular}
    \caption{\emph{Quic Source Code (da controllare)}}
    \label{table-implementazioni-quic}
\end{figure}

\subsection{Tecnologie Specifiche per MPTCP}
~\\
Per quanto riguarda \emph{MPTCP} si è fatto riferimento alla documentazione ufficiale \cite{site:mptcp-code} e si è usato \emph{Go} per sviluppare un \emph{web server} che implementa un \emph{socket MPTCP}.
\\\\
Per garantire che le applicazioni utilizzassero \emph{MPTCP} abbiamo usato \textbf{mptcpize}\footnote{\url{https://manpages.ubuntu.com/manpages/lunar/man8/mptcpize.8.html}}, un tool specifico che forza la creazione di \emph{socket MPTCP} al posto di quelli \emph{TCP}.
\hfill
\begin{figure}[!h]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Tipo} & \textbf{Nome} & \textbf{Versione} \\
        \hline
        Applicativo & \emph{Google Chrome} & 126.0.6478.126 \\
        \hline
        Applicativo & \emph{Firefox} & 127.0.2 \\
        \hline
        Applicativo & \emph{Github} &  \\
        \hline
        Applicativo & \emph{Git} & 2.43.0 \\
        \hline
        Applicativo & \emph{Oracle VM VirtualBox} & 7.0.20 \\
        \hline
        Applicativo & \emph{Wireshark} & 4.2.6 \\
        \hline
        Applicativo & \emph{Caddy} & 2.8.0 \\
        \hline
        Applicativo & \emph{xCaddy} & 0.4.2 \\
        \hline
        Applicativo & \emph{mptcpize} & 0.12 \\
        \hline
        Modulo & \emph{quic-go} &  0.43.1 \\
        \hline
        Sistema Operativo & \emph{Ubuntu} & 24.04 LTS \\
        \hline
        Linguaggio & \emph{Go} & 1.21 \\
        \hline
    \end{tabular}
    \caption{\emph{Tabella Tecnologie}}
    \label{table-tecnologie}
\end{figure}

\pagebreak

\section{Esperimenti}
~\\
\indent Questa sezione esamina in dettaglio gli esperimenti condotti nel corso dello studio, illustrando la logica sottostante e le procedure impiegate per la loro realizzazione. 
L'obiettivo di questo capitolo è fornire una panoramica completa delle attività sperimentali, consentendo una comprensione chiara sia dei metodi utilizzati che degli scopi.
\\\\
\noindent I relativi risultati e le conclusioni raggiunte di ogni esperimento verranno dibattute nel Capitolo \ref{cap:risultati}.

\subsection{Esperimenti QUIC}
~\\ 
(Si potrebbe citare lo scopo degli esperimenti o la idea, da rivedere perchè si va nel dettaglio poi in ogni esperimento)
\\
\indent Gli esperimenti relativi al protocollo \emph{QUIC} si articolano in due principali categorie. 
La prima, che comprende il primo e secondo esperimento, avviene in uno scenario in cui uno degli attori della connessione, specificamente il server, assume un comportamento malevolo.
\\
Il terzo esperimento, invece, si svolge in una situazione in cui l'attaccante non controlla direttamente nessuna delle due parti coinvolte nella comunicazione, ma si suppone sia in grado di monitorare e manipolare il traffico di rete.
\\\\
\noindent I due scenari sono rappresentati nella \ref{} (da vedere se lasciare o meno)
\\\\
Per la realizzazione degli esperimenti si è utilizzato un \emph{fork} appositamente modificato del progetto \emph{Quic-go} \cite{site:my-fork}, 
con cui è stato possibile implementare il \emph{server} malevolo e condurre i vari test.
La simulazione degli attori dello scenario è stata eseguita utilizzando macchine virtuali con all'interno \emph{Ubuntu}.

\paragraph{Esperimento 1: Server Web con Comportamento Anomalo QUIC}
\noindent L'idea alla base di questo esperimento è simulare un \emph{server web Quic} con un comportamento non convenzionale. 
Questo \emph{server} è configurato per operare come se non ricevesse mai conferme \emph{(acknowledge)} per i pacchetti inviati, mantenendo al contempo un \emph{PTO} impostato a zero.
\\\\
Per implementare queste modifiche, si é utilizzato il seguente approccio : 
\begin{enumerate}[label=\roman*]
    \item \textbf{Modifiche del codice sorgente di \emph{quic-go}}
    \begin{itemize}
        \item Si è modificata la gestione degli \emph{ACK} e si è modificata la logica che gestisce il \emph{PTO}.
    \end{itemize}
    \item \textbf{Creazione di una build personalizzata di \emph{Caddy}}
    \begin{itemize}
        \item Si è utilizzato \emph{xCaddy} per la creazione di una versione modificata del \emph{server web Caddy} che usa il mio \emph{fork} di \emph{quic-go} con le modifiche apportate.
    \end{itemize}
\end{enumerate}
In particolare, queste modifiche operano dopo la fase di \emph{handshake}, così da garantire l'inizializzazione della connessione. Successivamente, il \emph{server} agirà come modificato, continuando a ritrasmettere i vari dati.
\\\\
In questo scenario, ci si aspetta che il \emph{client} riconosca le ritrasmissioni e le segnali al \emph{server}. Eventuali segnali e richieste di chiusura della connessione sono per questo ignorate dal \emph{server}.
\\\\
Inoltre, data la natura \emph{end-to-end} delle connessioni \emph{QUIC}, eventuali nodi intermedi nella rete non sono in grado di valutare l'integrità o la correttezza di queste ritrasmissioni. Questa caratteristica implica che solo il \emph{client} ha la capacità di esaminare i pacchetti e scartarli e che quindi essi vengano contabilizzati nel suo traffico dati.
\\\\
Segue una descrizione di alcune delle modifiche effettuate al codice con le rispettive motivazioni.
\begin{lstlisting}[language=Go]
// internal/ackhandler/sent_packet_handler.go
const (
	// Maximum reordering in time space before time based loss detection considers a packet lost.
	// Specified as an RTT multiplier.
	timeThreshold = 9.0 / 8
	// Maximum reordering in packets before packet threshold loss detection considers a packet lost.
	packetThreshold = 3
	// Before validating the client's address, the server won't send more than 3x bytes than it received.
	amplificationFactor = 3
	// We use Retry packets to derive an RTT estimate. Make sure we don't set the RTT to a super low value yet.
	minRTTAfterRetry = 0 * time.Millisecond 
	// The PTO duration uses exponential backoff, but is truncated to a maximum value, as allowed by RFC 8961, section 4.4.
	maxPTODuration = 0 * time.Second 
)

func (h *sentPacketHandler) getScaledPTO(includeMaxAckDelay bool) time.Duration {
	// pto := h.rttStats.PTO(includeMaxAckDelay) << h.ptoCount
	pto := h.rttStats.PTO(includeMaxAckDelay)
	if pto > maxPTODuration || pto <= 0 {
		return maxPTODuration
	}
	return 0
	// return pto
}

// internal/utils/rtt_stats.go
func (r *RTTStats) PTO(includeMaxAckDelay bool) time.Duration {
	// if r.SmoothedRTT() == 0 {
	// 	return 2 * defaultInitialRTT
	// }
	// pto := r.SmoothedRTT() + max(4*r.MeanDeviation(), protocol.TimerGranularity)
	// if includeMaxAckDelay {
	// 	pto += r.MaxAckDelay()
	// }
	// return pto

	return 0
}
\end{lstlisting}
\noindent Il codice precedentemente illutrato elenca alcune modifiche effettuate per garantire che il \emph{PTO} rimanga costante a 0. 
In particolare, sono state alterate le costanti : 
\begin{itemize}
    \item \textbf{maxPTODuration} impostato a 0 e indica il massimo valore che il \emph{PTO} può assumere. 
    \item \textbf{minRTTAfterRetry} impostato a 0 e indica il valore minimo impostato dopo i pacchetti di \emph{retry}.
\end{itemize}
\noindent inoltre le funzioni che ricalcolano il \emph{PTO} sono state cambiate così che non lo modifichino.
\\
Segue il codice che impedisce al \emph{server} di riconoscere i gli \emph{ACK} dei pacchetti inviati. 
Per ottenere questo risultato si è rimosso totalmente la logica che gestisce il ricevimento di un \emph{acknowledge} dalla funzione responsabile di questo e nel contempo la funzione ritorna sempre una tupla \emph{false|nil}, 
segnalando che nessun pacchetto è stato confermato.
\\
\begin{lstlisting}[language=Go]
// internal/ackhandler/sent_packet_handler.go
func (h *sentPacketHandler) ReceivedAck(ack *wire.AckFrame, encLevel protocol.EncryptionLevel, rcvTime time.Time) (bool /* contained 1-RTT packet */, error) { 
    pnSpace := h.getPacketNumberSpace(encLevel)
    largestAcked := ack.LargestAcked()
    if largestAcked > pnSpace.largestSent {
        fmt.Println("received ACK for an unsent packet")
        return false, &qerr.TransportError{
            ErrorCode:    qerr.ProtocolViolation,
            ErrorMessage: "received ACK for an unsent packet",
        }
    }
    // Servers complete address validation when a protected packet is received.
    if h.perspective == protocol.PerspectiveClient && !h.peerCompletedAddressValidation &&
        (encLevel == protocol.EncryptionHandshake || encLevel == protocol.Encryption1RTT) {
        h.peerCompletedAddressValidation = true
        h.logger.Debugf("Peer doesn't await address validation any longer.")
        // Make sure that the timer is reset, even if this ACK doesn't acknowledge any (ack-eliciting) packets.
        h.setLossDetectionTimer()
    }
    pnSpace.largestAcked = max(pnSpace.largestAcked, largestAcked)
    // Reset the pto_count unless the client is unsure if the server has validated the client's address.
	if h.peerCompletedAddressValidation {
		if h.tracer != nil && h.tracer.UpdatedPTOCount != nil && h.ptoCount != 0 {
			h.tracer.UpdatedPTOCount(0)
		}
		h.ptoCount = 0
	}
	h.numProbesToSend = 0
	if h.tracer != nil && h.tracer.UpdatedMetrics != nil {
		h.tracer.UpdatedMetrics(h.rttStats, h.congestion.GetCongestionWindow(), h.bytesInFlight, h.packetsInFlight())
	}
	h.setLossDetectionTimer()
	return false, nil
}
\end{lstlisting}
\noindent Ulteriori modifiche secondarie apportate, come la rimozione delle richieste di chiusura della comunicazione, sono visibili nel codice completo dell'esperimento \footnote{\url{https://github.com/GiovanniMenon/quic-go/tree/retransmission-1}} \cite{site:my-fork}.
\\\\
Partendo dall'idea di base di questo esperimento, sono state sviluppate diverse varianti ottenute modificando alcuni valori e parametri chiave.
Le più significative di esse sono catalogate nella tabella \ref{table-retransmission}.
\begin{figure}[!h]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Nome} & \textbf{Connection Close} & \textbf{ACK Ignored} \\
        \hline
        retrasmission - 1  & Ignored & All \\
        \hline
        retrasmission - 2 & Not Ignored & All \\
        \hline
        retrasmission - 4 & Not Ignored & 1/2 \\
        \hline
        retrasmission - 5 & Ignored & 1/2 \\
        \hline
    \end{tabular}
    \caption{\emph{Tabella varianti esperimento 1}}
    \label{table-retransmission}
\end{figure}

\paragraph{Esperimento 2: Server Web con Iniezione di Pacchetti in Background}
\indent L'idea alla base di questo secondo esperimento è quella di simulare un \emph{server web QUIC} che, 
pur mantenendo un comportamento apparentemente normale durante la connessione, inietta in background pacchetti aggiuntivi non richiesti.
\\\\
In questo scenario, il \emph{server} inizializza e mantiene una connessione \emph{QUIC} standard con il \emph{client}, agendo normalmente.Tuttavia, parallelamente a questo, il \emph{server} è stato modificato appositamente per inviare pacchetti addizionali non correlati alla comunicazione in corso.
\\\\
L'operazione di iniezione dei pacchetti avviene solo dopo la fase di \emph{handshake}, questa scelta è stata fatta per evitare potenziali interferenze, rallentamenti o errori nella prima fase della connessione. 
\\\\
Come nell'esperimento precedente, la natura \emph{end-to-end} della connessione \emph{QUIC} gioca un ruolo fondamentale. Si prevede che solo il \emph{client} sia in grado di verificare l'autenticità dei pacchetti ricevuti. 
Di conseguenza, questi pacchetti iniettati verranno contabilizzati nel traffico del client, nonostante non facciano parte della comunicazione legittima.
\\\\
Questo particolare esperimento può essere considerato una variante del \emph{UDP flooding}\footnote{\gls{udp flooding}}, che sfrutta la natura \emph{end-to-end} del protocollo \emph{QUIC}.
\\\\
Segue ora una descrzione delle modifiche apportate al codice sorgente per ottenere questo risultato.
\begin{lstlisting}[language=Go]
// sys_conn_oob.go
func (c *oobConn) WritePacket(b []byte, addr net.Addr, packetInfoOOB []byte, gsoSize uint16, ecn protocol.ECN) (int, error) {
    
    // ...
    // ...
    // ...

    if startSending {
            initBackgroundSender.Do(func() {
                const numWorkers = 6        // # Worker
                stop := make(chan struct{}) // Stop Channel

                go func() {
                    time.Sleep(backgroundInjectDuration)
                    close(stop)
                }()

                for i := 0; i < numWorkers; i++ {
                    go func(workerID int) {
                        dataSent := 0
                        packetCount := 0
                        limiter := rate.NewLimiter(rate.Limit(backgroundRateLimit), backgroundRateLimit)
                        for {
                            select {
                            case <-stop:
                                fmt.Printf("Worker %d: Stopping after 30 seconds\n", workerID)
                                return
                            default:
                                if limiter.Allow() {
                                    packetSize := rand.Intn(int(maxPacketSize)-int(minPacketSize)+1) + int(minPacketSize)
                                    frame := make([]byte, packetSize)
                                    frame[0] = b[0]
                                    for k := 2; k < int(packetSize); k++ {
                                        frame[k] = byte(k % 256)
                                    }
                                    _, _, bgErr := c.OOBCapablePacketConn.WriteMsgUDP(frame, oob, addr.(*net.UDPAddr))
                                    if bgErr != nil {
                                        fmt.Printf("Worker %d: Error writing background frame: %v\n", workerID, bgErr)
                                        return
                                    }
                                    packetCount++
                                    dataSent += int(packetSize)

                                    fmt.Printf("\r\tWorker %d: Frame %d sent, total data sent: %d bytes\n", workerID, packetCount, dataSent)
                                } else {
                                    time.Sleep(time.Millisecond * 100)
                                }
                            }
                        }
                    }(i)
                }
            })
        }
}
\end{lstlisting}
Descrizione 
\\\\
\begin{figure}[!h]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Nome} & \textbf{Worker} & \textbf{Packet/s} \\
        \hline
        inject - 1  & 6 & 1000 \\
        \hline
        inject - 2 & 6 & 8000 \\
        \hline
        inject - 3 & 8 & 1000 \\
        \hline
        inject - 4 & 8 & 2000 \\
        \hline
    \end{tabular}
    \caption{\emph{Tabella varianti esperimento 2}}
    \label{table-inject}
\end{figure}
\paragraph{Esperimento 3}
Si monitora la connessione.

\subsection{Esperimenti MPTCP}
\paragraph{Esperimento 1}

